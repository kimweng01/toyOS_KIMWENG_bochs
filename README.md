# toyOS_KIMWENG_bochs
### Project簡介
本Project主要在結合恐龍本「作業系統概念」之教科書、書籍「作業系統真象還原」、書籍「30天打造OS! 作業系統自作入門」，實現一個具有基礎功能的作業系統，主要以「作業系統真象還原」為主，「30天打造OS! 作業系統自作入門」為輔，進行code的仿寫，改良了一些我覺得比較好的寫法，並特別撰寫參考書的閱讀筆記，紀錄重要的內容以及個人覺得作者可以改善的地方。
### 目標
本Project主要以Linux為基礎實現一個有基本功能的作業系統，kernel內含有中斷處理、記憶體管理、程序管理、輸入輸出系統、檔案系統等諸多作業系統核心的基礎功能。此外，也要為本kernel設計一個簡單的shell，
可以輸入基本的Linux指令讓使用者與系統作互動。
### 工具
開發環境:在Ubuntu平台上安裝bochs，使用bochs作開發。
程式語言:x86組語結合C語言作開發。
### 技術要點 
#### 中斷處理的方式
首先先初始化跟中斷有關的內容，再初始化計時控制器8259A，接著開中斷，等待中斷發生，中斷發生後，CPU會先壓棧，如果有特權等級變化，會先壓入SS(堆疊基址)和ESP，沒有特權等級變化則不壓這兩個入棧，然後壓入EFLAGS、CS、EIP、ERROR_CODE，然後用中斷描述符號暫存器(IDTR)找到IDT的基礎地址，接著用中斷向量號(時脈中斷是0x20)找對應的中斷門描述符號，中斷門描述符內有GDT選擇子，可以選擇GDT內第幾個段描述符號，得到段基礎位址，然後把IDT內的偏移量+段基礎位址，得到中斷處理常式在記憶體的位址，最後跳到中斷處理常式進行中斷處理，中斷處理結束後，藉由彈出棧的方式恢復上下文環境，最後從中斷返回。

#### 記憶體管理概念
由於直接採用物理地址對應到實體記憶體的方式很容易使記憶體可用空間形成碎塊，為了提升記憶體的使用效率，在此採用分頁的機制，使連續的虛擬位址藉由查詢分頁表的方式對應到不連續的實體位址，讓不連續的記憶體空間可以一起使用，有效避免了記憶體空間不足的問題。
本記憶體管理系統規劃了物理記憶體池和虛擬位址池，兩者皆包含user使用的部分和kernel使用的部分，若要申請N頁的記憶體，則先從虛擬位址池尋找N個連續可用的虛擬位址，然後再從物理記憶體池尋找N個不連續的空閒分頁，把物理位址填寫到虛擬位址對應到分頁表內的位址，這樣N個連續的虛擬位址就可以對應到不連續的物理位址了。
本Project還實現了malloc和free之功能，當malloc申請的記憶體很大時，直接以分頁為單位進行記憶體的分配；若申請的記憶體很小，直接以分配一個分頁大小的記憶體稍嫌浪費，所以可以把一個分頁切成好幾個等分的記憶體，然後把這些小記憶體放入鏈結串列內，當用malloc申請小記憶體時，直接從鏈結串列pop一個小記憶體使用，當鏈結串列掛的記憶體都被pop掉時，再申請一個新分頁，再把一個分頁切成好幾個等分的記憶體並放入鏈結串列內，這樣就可以繼續分配小記憶體。

#### 程序管理概念:
當有兩個以上的task時，為了讓多程序能夠同步，所以在此設計了程序管理的系統，為每個程序分配時間，當其中一個程序運行的tick到了，就會藉由排程器換下CPU並放入就緒隊列，而排程器會從就緒隊列pop出一個新的程序並放上CPU，使程序能交替運行。
有於有些程序有最小的操作單位，例如當某一個程序正在輸出一段資料到螢幕上時，該工作不應被打擾，因此在此引入信號量的機制。信號量初始值為1，當A程序要執行一個不希望被打擾的工作，則進入臨界區並把信號量設為0，若A程序正在執行一個不希望被打擾的工作時因為tick數到了而被交棒給B程序，而B程序又要做跟A一樣的工作，則此時B就會先被排程器放入等待隊列並把B程序Block住並交棒給下一程序，若A程序又被重新放回CPU並把工作執行完了，離開臨界區時會喚醒B程序，讓B程序被交棒時可以繼續運行。

#### 檔案系統概念:
本Project參考Linux的方式，使用inode和索引塊表的方式實現檔案的管理，inode紀錄了某檔案的重要資訊，包括檔案名、分布在硬碟的哪些位置等等，藉由索引塊表紀錄檔案的內容在硬碟內的各個位置。
假如現在要開啟某個路徑下的檔案，則先檢查該路徑下的檔案存不存在並獲得該檔案對應到的inode的編號，接著把該inode編號對應到的inode從硬碟上載到記憶體，最後為該檔案賦予一個檔案編號並記錄在程序控制塊內，實現檔案的開啟。
假如現在要讀取某個路徑下的檔案，一樣先檢查該路徑下的檔案存不存在並獲得該檔案對應到的inode的編號，接著把該inode編號對應到的inode從硬碟上載到記憶體，最後為該檔案賦予一個檔案編號並記錄在程序控制塊內，實現檔案的開啟。
